# 섹션 4.스토리북과 크로마틱을 활용한 시각적 회귀 테스트

## 3.1 시각적 회귀 테스트를 위한 스토리북

스토리북은 테스트 라이브러리라기 보다는 UI 개발도구에 가까움. 하지만 컴포넌트 개발의 효율성과 정확성을 높여준다.

스토리를 기준으로 시각적 회귀 테스트를 실행할 수 있다.

preview.jsx는 스토리를 렌더링할때 필요한 공통 설정을 다룸

- decorators: 주로 스토리를 렌더링할 때 특정 컴포넌트를 감싸거나 시블링? 컴포넌트 추가설정시 사용

스토리북은 굳이 실제 api 를 호출하여 사용할 필요가 없어서 msw 사용하면 좋음

스토리북

- 스토리북은 로직 및 컨텍스트의 간섭없이 원하는 컴포넌트를 시나리오별로 렌더링할 수 있도록 도와주는 개발 도구
- 단위 통합 테스트로 컴포넌트의 기능과 비즈니스 로직을 검증하며, 스토리북으로는 컴포넌트의 실제 UI를 검증한다.

시각적 회귀 테스트

- UI 변경 사항이 발생했을 때 기존과 다른 점이 있는지 비교하여 검증하고, 예상치 못한 문제가 있는지 반복적으로 검증하는 테스트
- 실제 렌더링 된 UI 결과의 이미지를 스냅샷으로 저장하여 비교, 검증한다
- 컴포넌트 시나리오별로 렌더링 되는 스토리북의 스토리는 시각적 회귀 테스트의 대상으로 활용하기 적합하다.

스토리북 렌더링에 사용되는 공통 설정은 .storybook 하위에서 정의할 수 있다.

## 3.2 스토리 작성하기

CSF의 핵심 구성요소

- 메타데이터
- 스토리

play함수: 스토리를 렌더링 한 뒤 사용자의 상호작용을 시뮬레이션, 내부적으로 Testing Library를 통해 구현, DOM과 상호작용을 하거나 어설션을 작성해 테스트도 가능
스토리의 최상위에서 동작함. 원하는 값을 시뮬레이션하며 스토리를 확인할 수 있음

### 스토리 작성 대상

props를 받아 UI만 렌더링하는 컴포넌트를 추가하면 좋음 => 렌더링 결과를 빠르게 확인할 수 있고 스토리를 상세화하면 설정없이 편하게 확인할 수 있다
X - 복잡한 비즈니스 로직이 있는 컴포넌트를 스토리로 작성할 경우, 몇가지 UI 확인을 위해 과한 모킹이 필요해짐
O - 비즈니스 로직이 모여있는 컴포넌트는 하위 컴포넌트를 대상으로 스토리를 상세화해 작성하자.
=> 스토리와 통합 테스트의 대상을 적절하게 나누기 위해서는 비즈니스 로직과 UI를 검증하기 위한 구조가 잘 나누어져 있어야 함
=> 자연스럽게 좋은 컴포넌트 설계 구조에 대한 고민으로!

## 3.3 크로마틱을 통한 UI 테스트 자동화

UI 시작적 회귀 테스트

UI에 변경사항이 발생했을 때 기존과 다른 점이 있는지 확인하고 예상치 못한 변경일 경우 결함으로 판단해 수정한다
=> 전문적인 도구를 사용해 스냅샷을 만들고 검증하는 것이 좋다

크로마틱을 사용할거임!

스토리북 메인테이너들이 만든 시각적 회귀테스트도구이고 스토리북 팀이 만듬. 워크플로우 환경 제공. 스토리북, CI와의 연동이 좋음

변경된 경우 크로마틱 페이지에 해당 사항이 뜸

- 일관된 환경에서 스냅샷을 촬영할 수 있음
- 고도화된 비교 알고리즘을 사용하기에 사용자 관점에서 테스트가 가능하다
- 다양한 운영체제, 브라우저에서 테스트할 수 있는 환경을 제공한다
- 변경 이력을 모두 저장하기 때문에 수정 사항 히스토리를 파악하기도 좋음

## 3.4 크로마틱을 활용한 시각적 회귀 테스트 워크플로우 만들기

1. 스토리북 작성 (CSF 형태로 작성)
2. 크로마틱 CI 연동 (.github/workflows/chromatic.yml)
3. UI 테스트 실행 (PR 하단 상태 확인)
4. PR 승인 및 머지
5. 스토리북 배포

- 시각적 회귀 테스트 자동화를 통한 예상치 못한 UI 변경사항 빠르게 검출
- 편하고 빠른 팀원들의 리뷰
- 자동화된 스토리북 배포를 통한 생산성 향상

## 3.5 시각적 회귀 테스트의 한계

- 실제렌더링된 UI 결과를 이미지 스냅샷으로 저장하여 비교
- 컴포넌트 스타일, 레이아웃에 대한 변경 사항까지 모두 감지
- 스토리북과의 연동이 편해 별도 코드없이 연동이 가능
- Github Action CI 연동을 통한 워크 플로우 자동화로 빠른 피드백 가능

### 한계점

1. 비용과 관리에 대한 부담 (월 5000개만 무료) => BackstopJS 대체 도구가 있으나 직접 환경구축해야함
2. 이슈의 원인을 파악하는데 오랜 시간이 걸린다 (명확한 테스트 설명이 존재하지 않음)
3. 피드백이 느림 => 로컬에서 실행해 바로 피드백을 받기 힘들다. 프로젝트 개발 단계에서 도입이 힘들다. TDD를 도입하는 것 또한 불가능
