# 섹션 6 통합 테스트 작성하기

> # Product Filter

- filter Store Mocking
- API MSW Mocking
- beforeEach Store Mocking
- API 호출은 비동기이기 때문에 getBy~ 를 사용하면 안되고, findBy~ 를 통해 검증해야한다.
  - findBy~ 는 API 응답이 완료될 때까지 재시도
- 스파이 함수로 스토어 액션 호출 여부 확인

> # Navigation Bar

- 기존에 모킹된 API 응답을 변경하기 위해서 MSW server 인스턴스를 활용한다.
  - 초기 구동을 위해 설정한 MSW server 인스턴스와 동일한 인스턴스를 사용해야 기존 모킹된 API의 응답을 변경할 수 있다.
  - server.use()를 통해 API의 응답을 변경한다.
  - 기존 handler.js 응답을 use 함수 내에 응답을 기준으로 테스트를 실행한다.
  - 테스트가 종료될 때마다 server.resetHandlers 함수를 호출하여 초기화를 시켜줘야한다.
  - 요소의 존재 여부를 판단할 때는 queryBy~ 를 사용한다.
  ```js
  server.use(
    rest.get("/user", (_, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          email: "maria@mail.com",
          id: userId,
          name: "Maria",
          password: "12345",
        })
      );
    })
  );
  ```
- route 검증
  ```js
  expect(navigateFn).toHaveBeenNthCalledWith(1, "/login", {
    state: { prevPath: "pathname" },
  });
  ```

> # 통합 테스트의 한계 - 구매 페이지

- 구성된 UI 컴포넌트들의 동작보다는 전채 플로우가 더 중요한 구매 페이지의 경우 중요한 플로우를 오로지 모킹에 의존해야한다는 이슈가 있다.
- 통합 테스트는 비즈니스 로직을 나누어 컴포넌트의 상호 작용을 검증하기 좋지만 전체적인 워크 플로우를 검증하기에는 한계가 있음.
- E2E 테스트로 워크 플로우로 검증할 수 있다.
  - E2E 테스트는 실제 앱을 구동시켜서 모킹에 의존하지 않고 실제 워크 플로우를 검증할 수 있다.
- 개발 단계에서는 단위/통합 테스트로 도메인 별 비즈니스 로직을 검증
- 완성 단계에서는 E2E 테스트로 전체 워크 플로우를 검증

> # Github Actions를 통한 테스트 자동화

- 빌드/테스트 및 배포 파이프라인을 자동화할 수 있는 CI/CD 플랫폼
- .github/workflows에 yml 파일로 정의한다
- 원하는 시점에 테스트 액션을 실행하여 피드백을 받을 수 있다.

> # 1부를 마무리하며

- 테스트란 ?
  - 앱의 품질과 안정성을 높이기 위해 사전에 결함을 찾아내기 위한 행위
- 테스트 코드의 효과
  - 리팩토링 , 문서, 좋은 설계
- 테스트 코드 작성 시 중요한 규칙
  - 인터페이스를 기준으로 작성하기
    - 내부 구현에 대한 의존성이 없어야 한다
    - UI와 이벤트를 기준으로 동작을 확인하자
  - 의미있는 테스트인지 고민하기
    - 커버리지 100% 보다 유의미한 기능을 검증할 수 있는지 확인하기
  - 테스트 코드의 가독성도 고려하기
    - 하나의 테스트에서는 가급적 하나의 동작만 검증
    - 명확한 디스크립션
- 무슨 테스트를 배웠을까?
  - 단위 테스트
    - 앱에서 테스트 가능한 작은 단위의 소프트웨어를 실행하여 예상대로 동작하는지 검증하는 테스트
    - 공통 컴포넌트, 리액트 훅, 유틸 함수 ( 독립적으로 동작하는 것들 )
  - 통합 테스트
    - 두 개 이상의 모듈이 상호작용하여 발생하는 상태를 검증하여 실제 앱과 유사하게 기능을 검증
    - 나누어진 비즈니스 로직에 따른 컴포넌트들의 조합
